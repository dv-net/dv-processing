// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: processed_incidents.sql

package repo_processed_incidents

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldIncidents = `-- name: CleanupOldIncidents :exec
DELETE FROM processed_incidents
WHERE created_at < NOW() - INTERVAL '30 days'
  AND status = 'completed'
`

func (q *Queries) CleanupOldIncidents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldIncidents)
	return err
}

const getIncompleteIncidents = `-- name: GetIncompleteIncidents :many
SELECT id, blockchain, incident_type, status, rollback_from_block, rollback_to_block, error_message, started_at, completed_at, created_at
FROM processed_incidents
WHERE blockchain = $1
  AND status = 'processing'
ORDER BY started_at ASC
`

func (q *Queries) GetIncompleteIncidents(ctx context.Context, blockchain wconstants.BlockchainType) ([]*models.ProcessedIncident, error) {
	rows, err := q.db.Query(ctx, getIncompleteIncidents, blockchain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.ProcessedIncident{}
	for rows.Next() {
		var i models.ProcessedIncident
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.IncidentType,
			&i.Status,
			&i.RollbackFromBlock,
			&i.RollbackToBlock,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isIncidentProcessed = `-- name: IsIncidentProcessed :one
SELECT EXISTS(
    SELECT 1
    FROM processed_incidents
    WHERE blockchain = $1 AND id = $2
) AS exists
`

func (q *Queries) IsIncidentProcessed(ctx context.Context, blockchain wconstants.BlockchainType, iD string) (bool, error) {
	row := q.db.QueryRow(ctx, isIncidentProcessed, blockchain, iD)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const markIncidentAsCompleted = `-- name: MarkIncidentAsCompleted :exec
UPDATE processed_incidents
SET status = 'completed',
    completed_at = NOW(),
    error_message = NULL
WHERE blockchain = $1 AND id = $2
`

func (q *Queries) MarkIncidentAsCompleted(ctx context.Context, blockchain wconstants.BlockchainType, iD string) error {
	_, err := q.db.Exec(ctx, markIncidentAsCompleted, blockchain, iD)
	return err
}

const markIncidentAsFailed = `-- name: MarkIncidentAsFailed :exec
UPDATE processed_incidents
SET status = 'failed',
    completed_at = NOW(),
    error_message = $3
WHERE blockchain = $1 AND id = $2
`

type MarkIncidentAsFailedParams struct {
	Blockchain   wconstants.BlockchainType `db:"blockchain" json:"blockchain"`
	ID           string                    `db:"id" json:"id"`
	ErrorMessage pgtype.Text               `db:"error_message" json:"error_message"`
}

func (q *Queries) MarkIncidentAsFailed(ctx context.Context, arg MarkIncidentAsFailedParams) error {
	_, err := q.db.Exec(ctx, markIncidentAsFailed, arg.Blockchain, arg.ID, arg.ErrorMessage)
	return err
}

const markIncidentAsProcessing = `-- name: MarkIncidentAsProcessing :exec
INSERT INTO processed_incidents (
    id,
    blockchain,
    incident_type,
    status,
    rollback_from_block,
    rollback_to_block,
    started_at
)
VALUES ($1, $2, $3, 'processing', $4, $5, NOW())
ON CONFLICT (id) DO UPDATE
SET status = 'processing',
    started_at = NOW()
`

type MarkIncidentAsProcessingParams struct {
	ID                string                    `db:"id" json:"id"`
	Blockchain        wconstants.BlockchainType `db:"blockchain" json:"blockchain"`
	IncidentType      string                    `db:"incident_type" json:"incident_type"`
	RollbackFromBlock pgtype.Int8               `db:"rollback_from_block" json:"rollback_from_block"`
	RollbackToBlock   pgtype.Int8               `db:"rollback_to_block" json:"rollback_to_block"`
}

func (q *Queries) MarkIncidentAsProcessing(ctx context.Context, arg MarkIncidentAsProcessingParams) error {
	_, err := q.db.Exec(ctx, markIncidentAsProcessing,
		arg.ID,
		arg.Blockchain,
		arg.IncidentType,
		arg.RollbackFromBlock,
		arg.RollbackToBlock,
	)
	return err
}
