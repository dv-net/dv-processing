// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfer_transactions.sql

package repo_transfer_transactions

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const findSystemTransactions = `-- name: FindSystemTransactions :many
SELECT tt.id, tt.transfer_id, tt.tx_hash, tt.bandwidth_amount, tt.energy_amount, tt.native_token_amount, tt.native_token_fee, tt.tx_type, tt.status, tt.step, tt.created_at, tt.updated_at
FROM transfer_transactions tt
         INNER JOIN transfers t ON t.id = tt.transfer_id AND t.owner_id = $1 AND
                                   t.blockchain = $2
WHERE tt.tx_hash = $3
  AND ($4::VARCHAR[] IS NULL OR tx_type = ANY ($4::VARCHAR[]))
`

type FindSystemTransactionsParams struct {
	OwnerID       uuid.UUID                 `db:"owner_id" json:"owner_id"`
	Blockchain    wconstants.BlockchainType `db:"blockchain" json:"blockchain"`
	TxHash        string                    `db:"tx_hash" json:"tx_hash"`
	SystemTxTypes []string                  `db:"system_tx_types" json:"system_tx_types"`
}

func (q *Queries) FindSystemTransactions(ctx context.Context, arg FindSystemTransactionsParams) ([]*models.TransferTransaction, error) {
	rows, err := q.db.Query(ctx, findSystemTransactions,
		arg.OwnerID,
		arg.Blockchain,
		arg.TxHash,
		arg.SystemTxTypes,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.TransferTransaction{}
	for rows.Next() {
		var i models.TransferTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TransferID,
			&i.TxHash,
			&i.BandwidthAmount,
			&i.EnergyAmount,
			&i.NativeTokenAmount,
			&i.NativeTokenFee,
			&i.TxType,
			&i.Status,
			&i.Step,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTransactionByType = `-- name: FindTransactionByType :many
SELECT id, transfer_id, tx_hash, bandwidth_amount, energy_amount, native_token_amount, native_token_fee, tx_type, status, step, created_at, updated_at
FROM transfer_transactions
WHERE transfer_id = $1
  AND tx_type = $2
`

func (q *Queries) FindTransactionByType(ctx context.Context, transferID uuid.UUID, txType models.TransferTransactionType) ([]*models.TransferTransaction, error) {
	rows, err := q.db.Query(ctx, findTransactionByType, transferID, txType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.TransferTransaction{}
	for rows.Next() {
		var i models.TransferTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TransferID,
			&i.TxHash,
			&i.BandwidthAmount,
			&i.EnergyAmount,
			&i.NativeTokenAmount,
			&i.NativeTokenFee,
			&i.TxType,
			&i.Status,
			&i.Step,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllByTransfer = `-- name: GetAllByTransfer :many
SELECT id, transfer_id, tx_hash, bandwidth_amount, energy_amount, native_token_amount, native_token_fee, tx_type, status, step, created_at, updated_at
FROM transfer_transactions tt
WHERE transfer_id = $1
`

func (q *Queries) GetAllByTransfer(ctx context.Context, transferID uuid.UUID) ([]*models.TransferTransaction, error) {
	rows, err := q.db.Query(ctx, getAllByTransfer, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.TransferTransaction{}
	for rows.Next() {
		var i models.TransferTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TransferID,
			&i.TxHash,
			&i.BandwidthAmount,
			&i.EnergyAmount,
			&i.NativeTokenAmount,
			&i.NativeTokenFee,
			&i.TxType,
			&i.Status,
			&i.Step,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByTransfer = `-- name: GetByTransfer :many
SELECT id, transfer_id, tx_hash, bandwidth_amount, energy_amount, native_token_amount, native_token_fee, tx_type, status, step, created_at, updated_at
FROM transfer_transactions
WHERE transfer_id = $1
`

func (q *Queries) GetByTransfer(ctx context.Context, transferID uuid.UUID) ([]*models.TransferTransaction, error) {
	rows, err := q.db.Query(ctx, getByTransfer, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.TransferTransaction{}
	for rows.Next() {
		var i models.TransferTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TransferID,
			&i.TxHash,
			&i.BandwidthAmount,
			&i.EnergyAmount,
			&i.NativeTokenAmount,
			&i.NativeTokenFee,
			&i.TxType,
			&i.Status,
			&i.Step,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePendingTxExpense = `-- name: UpdatePendingTxExpense :exec
UPDATE transfer_transactions
SET bandwidth_amount    = $1,
    energy_amount       = $2,
    native_token_amount = $3,
    native_token_fee    = $4,
    status              = $5,
    updated_at          = now()
WHERE transfer_id = $6
  AND tx_hash = $7
`

type UpdatePendingTxExpenseParams struct {
	BandwidthAmount   decimal.Decimal                   `db:"bandwidth_amount" json:"bandwidth_amount"`
	EnergyAmount      decimal.Decimal                   `db:"energy_amount" json:"energy_amount"`
	NativeTokenAmount decimal.Decimal                   `db:"native_token_amount" json:"native_token_amount"`
	NativeTokenFee    decimal.Decimal                   `db:"native_token_fee" json:"native_token_fee"`
	CurrentTxStatus   models.TransferTransactionsStatus `db:"current_tx_status" json:"current_tx_status"`
	TransferID        uuid.UUID                         `db:"transfer_id" json:"transfer_id"`
	TxHash            string                            `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) UpdatePendingTxExpense(ctx context.Context, arg UpdatePendingTxExpenseParams) error {
	_, err := q.db.Exec(ctx, updatePendingTxExpense,
		arg.BandwidthAmount,
		arg.EnergyAmount,
		arg.NativeTokenAmount,
		arg.NativeTokenFee,
		arg.CurrentTxStatus,
		arg.TransferID,
		arg.TxHash,
	)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE transfer_transactions
SET status = $2, updated_at = now()
WHERE id = $1
`

func (q *Queries) UpdateStatus(ctx context.Context, iD uuid.UUID, status models.TransferTransactionsStatus) error {
	_, err := q.db.Exec(ctx, updateStatus, iD, status)
	return err
}
