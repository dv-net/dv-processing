// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transfers.sql

package repo_transfers

import (
	"context"

	"github.com/dv-net/dv-processing/internal/constants"
	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/internal/workflow"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const existsByTxHashAndOwnerID = `-- name: ExistsByTxHashAndOwnerID :one
select exists(select 1 from transfers where tx_hash = $1 and owner_id = $2)
`

func (q *Queries) ExistsByTxHashAndOwnerID(ctx context.Context, txHash pgtype.Text, ownerID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, existsByTxHashAndOwnerID, txHash, ownerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findAllNewTransfers = `-- name: FindAllNewTransfers :many
select id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot from transfers where status = 'new' order by created_at asc limit 100
`

func (q *Queries) FindAllNewTransfers(ctx context.Context) ([]*models.Transfer, error) {
	rows, err := q.db.Query(ctx, findAllNewTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transfer{}
	for rows.Next() {
		var i models.Transfer
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ClientID,
			&i.OwnerID,
			&i.RequestID,
			&i.Blockchain,
			&i.FromAddresses,
			&i.ToAddresses,
			&i.WalletFromType,
			&i.AssetIdentifier,
			&i.Kind,
			&i.WholeAmount,
			&i.Amount,
			&i.Fee,
			&i.FeeMax,
			&i.TxHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StateData,
			&i.WorkflowSnapshot,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTronTransfersBurn = `-- name: GetActiveTronTransfersBurn :one
with dataset as (
	select id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot from transfers where blockchain = 'tron' and kind = 'burntrx' and status in ('new', 'processing', 'unconfirmed')
)
select
	coalesce(sum((state_data->'estimated_resources'->>'trx')::numeric),0)::numeric trx,
	coalesce(sum((state_data->'estimated_activation'->>'energy')::numeric),0)::numeric activation_energy,
	coalesce(sum((state_data->'estimated_activation'->>'bandwidth')::numeric),0)::numeric activation_bandwidth,
	coalesce(sum((state_data->'estimated_activation'->>'trx')::numeric),0)::numeric activation_trx
	from dataset
	where state_data->'estimated_resources'->'trx' is not null and state_data->'estimated_activation'->'energy' is not null and state_data->'estimated_activation'->'bandwidth' is not null and state_data->'estimated_activation'->'trx' is not null
`

type GetActiveTronTransfersBurnRow struct {
	Trx                 decimal.Decimal `db:"trx" json:"trx"`
	ActivationEnergy    decimal.Decimal `db:"activation_energy" json:"activation_energy"`
	ActivationBandwidth decimal.Decimal `db:"activation_bandwidth" json:"activation_bandwidth"`
	ActivationTrx       decimal.Decimal `db:"activation_trx" json:"activation_trx"`
}

func (q *Queries) GetActiveTronTransfersBurn(ctx context.Context) (*GetActiveTronTransfersBurnRow, error) {
	row := q.db.QueryRow(ctx, getActiveTronTransfersBurn)
	var i GetActiveTronTransfersBurnRow
	err := row.Scan(
		&i.Trx,
		&i.ActivationEnergy,
		&i.ActivationBandwidth,
		&i.ActivationTrx,
	)
	return &i, err
}

const getActiveTronTransfersResources = `-- name: GetActiveTronTransfersResources :one
with dataset as (
	select id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot from transfers where blockchain = 'tron' and kind = 'resources' and status in ('new', 'processing', 'unconfirmed')
)
select
	coalesce(sum((state_data->'estimated_resources'->'need_to_delegate'->>'energy')::numeric),0)::numeric energy,
	coalesce(sum((state_data->'estimated_resources'->>'need_bandwidth_from_processing_wallet')::numeric),0)::numeric bandwidth,
	coalesce(sum((state_data->'estimated_activation'->>'energy')::numeric),0)::numeric activation_energy,
	coalesce(sum((state_data->'estimated_activation'->>'bandwidth')::numeric),0)::numeric activation_bandwidth
	from dataset
	where state_data->'estimated_resources'->'need_to_delegate'->'energy' is not null and state_data->'estimated_resources'->'need_bandwidth_from_processing_wallet' is not null and state_data->'estimated_activation'->'energy' is not null and state_data->'estimated_activation'->'bandwidth' is not null
`

type GetActiveTronTransfersResourcesRow struct {
	Energy              decimal.Decimal `db:"energy" json:"energy"`
	Bandwidth           decimal.Decimal `db:"bandwidth" json:"bandwidth"`
	ActivationEnergy    decimal.Decimal `db:"activation_energy" json:"activation_energy"`
	ActivationBandwidth decimal.Decimal `db:"activation_bandwidth" json:"activation_bandwidth"`
}

func (q *Queries) GetActiveTronTransfersResources(ctx context.Context) (*GetActiveTronTransfersResourcesRow, error) {
	row := q.db.QueryRow(ctx, getActiveTronTransfersResources)
	var i GetActiveTronTransfersResourcesRow
	err := row.Scan(
		&i.Energy,
		&i.Bandwidth,
		&i.ActivationEnergy,
		&i.ActivationBandwidth,
	)
	return &i, err
}

const getByRequestID = `-- name: GetByRequestID :one
select id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot from transfers where request_id = $1
`

func (q *Queries) GetByRequestID(ctx context.Context, requestID string) (*models.Transfer, error) {
	row := q.db.QueryRow(ctx, getByRequestID, requestID)
	var i models.Transfer
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ClientID,
		&i.OwnerID,
		&i.RequestID,
		&i.Blockchain,
		&i.FromAddresses,
		&i.ToAddresses,
		&i.WalletFromType,
		&i.AssetIdentifier,
		&i.Kind,
		&i.WholeAmount,
		&i.Amount,
		&i.Fee,
		&i.FeeMax,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StateData,
		&i.WorkflowSnapshot,
	)
	return &i, err
}

const getByTxHashAndOwnerID = `-- name: GetByTxHashAndOwnerID :one
select id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot from transfers where tx_hash = $1 and owner_id = $2
`

func (q *Queries) GetByTxHashAndOwnerID(ctx context.Context, txHash pgtype.Text, ownerID uuid.UUID) (*models.Transfer, error) {
	row := q.db.QueryRow(ctx, getByTxHashAndOwnerID, txHash, ownerID)
	var i models.Transfer
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ClientID,
		&i.OwnerID,
		&i.RequestID,
		&i.Blockchain,
		&i.FromAddresses,
		&i.ToAddresses,
		&i.WalletFromType,
		&i.AssetIdentifier,
		&i.Kind,
		&i.WholeAmount,
		&i.Amount,
		&i.Fee,
		&i.FeeMax,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StateData,
		&i.WorkflowSnapshot,
	)
	return &i, err
}

const getStateData = `-- name: GetStateData :one
SELECT state_data FROM transfers WHERE id = $1
`

func (q *Queries) GetStateData(ctx context.Context, id uuid.UUID) (map[string]any, error) {
	row := q.db.QueryRow(ctx, getStateData, id)
	var state_data map[string]any
	err := row.Scan(&state_data)
	return state_data, err
}

const getWorkflowSnapshot = `-- name: GetWorkflowSnapshot :one
SELECT workflow_snapshot FROM transfers WHERE id = $1
`

func (q *Queries) GetWorkflowSnapshot(ctx context.Context, id uuid.UUID) (workflow.Snapshot, error) {
	row := q.db.QueryRow(ctx, getWorkflowSnapshot, id)
	var workflow_snapshot workflow.Snapshot
	err := row.Scan(&workflow_snapshot)
	return workflow_snapshot, err
}

const setStateData = `-- name: SetStateData :exec
UPDATE transfers SET state_data = $2, updated_at = now() WHERE id = $1
`

func (q *Queries) SetStateData(ctx context.Context, iD uuid.UUID, stateData map[string]any) error {
	_, err := q.db.Exec(ctx, setStateData, iD, stateData)
	return err
}

const setStatus = `-- name: SetStatus :exec
update transfers set updated_at = now(), status = $2 where id = $1
`

func (q *Queries) SetStatus(ctx context.Context, iD uuid.UUID, status constants.TransferStatus) error {
	_, err := q.db.Exec(ctx, setStatus, iD, status)
	return err
}

const setTxHash = `-- name: SetTxHash :one
update transfers set updated_at = now(), tx_hash = $2 where id = $1 returning id, status, client_id, owner_id, request_id, blockchain, from_addresses, to_addresses, wallet_from_type, asset_identifier, kind, whole_amount, amount, fee, fee_max, tx_hash, created_at, updated_at, state_data, workflow_snapshot
`

func (q *Queries) SetTxHash(ctx context.Context, iD uuid.UUID, txHash pgtype.Text) (*models.Transfer, error) {
	row := q.db.QueryRow(ctx, setTxHash, iD, txHash)
	var i models.Transfer
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ClientID,
		&i.OwnerID,
		&i.RequestID,
		&i.Blockchain,
		&i.FromAddresses,
		&i.ToAddresses,
		&i.WalletFromType,
		&i.AssetIdentifier,
		&i.Kind,
		&i.WholeAmount,
		&i.Amount,
		&i.Fee,
		&i.FeeMax,
		&i.TxHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StateData,
		&i.WorkflowSnapshot,
	)
	return &i, err
}

const setWorkflowSnapshot = `-- name: SetWorkflowSnapshot :exec
UPDATE transfers SET workflow_snapshot = $2, updated_at = now() WHERE id = $1
`

func (q *Queries) SetWorkflowSnapshot(ctx context.Context, iD uuid.UUID, workflowSnapshot workflow.Snapshot) error {
	_, err := q.db.Exec(ctx, setWorkflowSnapshot, iD, workflowSnapshot)
	return err
}
