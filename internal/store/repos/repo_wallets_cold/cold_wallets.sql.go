// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cold_wallets.sql

package repo_wallets_cold

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/google/uuid"
)

const get = `-- name: Get :one
select id, blockchain, address, owner_id, is_active, is_dirty, created_at, updated_at from cold_wallets where owner_id = $1 and blockchain = $2 and address = $3 LIMIT 1
`

type GetParams struct {
	OwnerID    uuid.UUID                 `db:"owner_id" json:"owner_id" validate:"required,uuid4"`
	Blockchain wconstants.BlockchainType `db:"blockchain" json:"blockchain" validate:"required"`
	Address    string                    `db:"address" json:"address" validate:"required"`
}

func (q *Queries) Get(ctx context.Context, arg GetParams) (*models.ColdWallet, error) {
	row := q.db.QueryRow(ctx, get, arg.OwnerID, arg.Blockchain, arg.Address)
	var i models.ColdWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAllByOwnerID = `-- name: GetAllByOwnerID :many
select id, blockchain, address, owner_id, is_active, is_dirty, created_at, updated_at from cold_wallets where owner_id = $1
`

func (q *Queries) GetAllByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]*models.ColdWallet, error) {
	rows, err := q.db.Query(ctx, getAllByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.ColdWallet{}
	for rows.Next() {
		var i models.ColdWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByBlockchainAndAddress = `-- name: GetByBlockchainAndAddress :one
select id, blockchain, address, owner_id, is_active, is_dirty, created_at, updated_at from cold_wallets where blockchain = $1 and address = $2
`

func (q *Queries) GetByBlockchainAndAddress(ctx context.Context, blockchain wconstants.BlockchainType, address string) (*models.ColdWallet, error) {
	row := q.db.QueryRow(ctx, getByBlockchainAndAddress, blockchain, address)
	var i models.ColdWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const maxSequence = `-- name: MaxSequence :one
select 
  coalesce(max(sequence),0)::int as sequence
from cold_wallets w
where w.blockchain = $1 and w.owner_id = $2
`

func (q *Queries) MaxSequence(ctx context.Context, blockchain wconstants.BlockchainType, ownerID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, maxSequence, blockchain, ownerID)
	var sequence int32
	err := row.Scan(&sequence)
	return sequence, err
}
