// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hot_wallets.sql

package repo_wallets_hot

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/google/uuid"
)

const activateWallet = `-- name: ActivateWallet :exec
update hot_wallets w set is_activated = true, updated_at = now() where w.blockchain = $1 and w.address = $2 and w.owner_id = $3
`

func (q *Queries) ActivateWallet(ctx context.Context, blockchain wconstants.BlockchainType, address string, ownerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, activateWallet, blockchain, address, ownerID)
	return err
}

const findEVMByExternalID = `-- name: FindEVMByExternalID :many
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where external_wallet_id = $1 and blockchain in (select unnest($2::text[])) and owner_id = $3 and is_active = true order by sequence desc limit 1
`

func (q *Queries) FindEVMByExternalID(ctx context.Context, externalWalletID string, column2 []string, ownerID uuid.UUID) ([]*models.HotWallet, error) {
	rows, err := q.db.Query(ctx, findEVMByExternalID, externalWalletID, column2, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.HotWallet{}
	for rows.Next() {
		var i models.HotWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.ExternalWalletID,
			&i.Sequence,
			&i.IsActivated,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get = `-- name: Get :one
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where address = $3 and owner_id = $1 and blockchain = $2 limit 1
`

func (q *Queries) Get(ctx context.Context, ownerID uuid.UUID, blockchain wconstants.BlockchainType, address string) (*models.HotWallet, error) {
	row := q.db.QueryRow(ctx, get, ownerID, blockchain, address)
	var i models.HotWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.ExternalWalletID,
		&i.Sequence,
		&i.IsActivated,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAll = `-- name: GetAll :many
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where is_active = true
`

func (q *Queries) GetAll(ctx context.Context) ([]*models.HotWallet, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.HotWallet{}
	for rows.Next() {
		var i models.HotWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.ExternalWalletID,
			&i.Sequence,
			&i.IsActivated,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllByOwnerID = `-- name: GetAllByOwnerID :many
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where owner_id = $1
`

func (q *Queries) GetAllByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]*models.HotWallet, error) {
	rows, err := q.db.Query(ctx, getAllByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.HotWallet{}
	for rows.Next() {
		var i models.HotWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.ExternalWalletID,
			&i.Sequence,
			&i.IsActivated,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByBlockchainAndAddress = `-- name: GetByBlockchainAndAddress :one
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where blockchain = $1 and address = $2
`

func (q *Queries) GetByBlockchainAndAddress(ctx context.Context, blockchain wconstants.BlockchainType, address string) (*models.HotWallet, error) {
	row := q.db.QueryRow(ctx, getByBlockchainAndAddress, blockchain, address)
	var i models.HotWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.ExternalWalletID,
		&i.Sequence,
		&i.IsActivated,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getManyByOwnerAndWalletAddresses = `-- name: GetManyByOwnerAndWalletAddresses :many
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where address in (select unnest($1::text[])) AND owner_id = $2
`

func (q *Queries) GetManyByOwnerAndWalletAddresses(ctx context.Context, column1 []string, ownerID uuid.UUID) ([]*models.HotWallet, error) {
	rows, err := q.db.Query(ctx, getManyByOwnerAndWalletAddresses, column1, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.HotWallet{}
	for rows.Next() {
		var i models.HotWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.ExternalWalletID,
			&i.Sequence,
			&i.IsActivated,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyByOwnerAndWalletIDs = `-- name: GetManyByOwnerAndWalletIDs :many
select id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at from hot_wallets where id in (select unnest($1::uuid[])) AND owner_id = $2
`

func (q *Queries) GetManyByOwnerAndWalletIDs(ctx context.Context, column1 []uuid.UUID, ownerID uuid.UUID) ([]*models.HotWallet, error) {
	rows, err := q.db.Query(ctx, getManyByOwnerAndWalletIDs, column1, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.HotWallet{}
	for rows.Next() {
		var i models.HotWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.ExternalWalletID,
			&i.Sequence,
			&i.IsActivated,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDirty = `-- name: MarkDirty :exec
update hot_wallets w set is_dirty = true, updated_at = now() where w.blockchain = $1 and w.address = $2 and w.owner_id = $3
`

func (q *Queries) MarkDirty(ctx context.Context, blockchain wconstants.BlockchainType, address string, ownerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markDirty, blockchain, address, ownerID)
	return err
}
