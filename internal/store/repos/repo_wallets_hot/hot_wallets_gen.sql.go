// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hot_wallets_gen.sql

package repo_wallets_hot

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/google/uuid"
)

const create = `-- name: Create :one
INSERT INTO hot_wallets (blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, created_at)
	VALUES ($1, $2, $3, $4, $5, $6, $7, now())
	RETURNING id, blockchain, address, owner_id, external_wallet_id, sequence, is_activated, is_active, is_dirty, created_at, updated_at
`

type CreateParams struct {
	Blockchain       wconstants.BlockchainType `db:"blockchain" json:"blockchain" validate:"required"`
	Address          string                    `db:"address" json:"address" validate:"required"`
	OwnerID          uuid.UUID                 `db:"owner_id" json:"owner_id" validate:"required,uuid4"`
	ExternalWalletID string                    `db:"external_wallet_id" json:"external_wallet_id" validate:"required"`
	Sequence         int32                     `db:"sequence" json:"sequence"`
	IsActivated      bool                      `db:"is_activated" json:"is_activated"`
	IsActive         bool                      `db:"is_active" json:"is_active"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*models.HotWallet, error) {
	row := q.db.QueryRow(ctx, create,
		arg.Blockchain,
		arg.Address,
		arg.OwnerID,
		arg.ExternalWalletID,
		arg.Sequence,
		arg.IsActivated,
		arg.IsActive,
	)
	var i models.HotWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.ExternalWalletID,
		&i.Sequence,
		&i.IsActivated,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const exist = `-- name: Exist :one
SELECT EXISTS (SELECT 1 FROM hot_wallets WHERE address=$1 AND blockchain=$2 AND owner_id=$3 LIMIT 1)::boolean
`

func (q *Queries) Exist(ctx context.Context, address string, blockchain wconstants.BlockchainType, ownerID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, exist, address, blockchain, ownerID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
