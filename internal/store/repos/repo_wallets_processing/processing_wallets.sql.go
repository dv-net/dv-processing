// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: processing_wallets.sql

package repo_wallets_processing

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/dv-net/dv-processing/pkg/walletsdk/wconstants"
	"github.com/google/uuid"
)

const get = `-- name: Get :one
select id, blockchain, address, owner_id, sequence, is_active, is_dirty, created_at, updated_at from processing_wallets where address = $2 and blockchain = $1 limit 1
`

func (q *Queries) Get(ctx context.Context, blockchain wconstants.BlockchainType, address string) (*models.ProcessingWallet, error) {
	row := q.db.QueryRow(ctx, get, blockchain, address)
	var i models.ProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.Sequence,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAllByOwnerID = `-- name: GetAllByOwnerID :many
select id, blockchain, address, owner_id, sequence, is_active, is_dirty, created_at, updated_at from processing_wallets where owner_id = $1
`

func (q *Queries) GetAllByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]*models.ProcessingWallet, error) {
	rows, err := q.db.Query(ctx, getAllByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.ProcessingWallet{}
	for rows.Next() {
		var i models.ProcessingWallet
		if err := rows.Scan(
			&i.ID,
			&i.Blockchain,
			&i.Address,
			&i.OwnerID,
			&i.Sequence,
			&i.IsActive,
			&i.IsDirty,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNotCreatedWallets = `-- name: GetAllNotCreatedWallets :many
WITH all_combinations AS (
  SELECT
    o.id owner_id,
    unnest($1::varchar[]) AS blockchain
  FROM owners o
),
missing_combinations AS (
  SELECT
    ac.owner_id,
    ac.blockchain::varchar blockchain
  FROM all_combinations ac
  LEFT JOIN processing_wallets w
  ON ac.owner_id = w.owner_id AND ac.blockchain = w.blockchain
  WHERE w.blockchain IS NULL
)
SELECT owner_id, blockchain FROM missing_combinations
`

type GetAllNotCreatedWalletsRow struct {
	OwnerID    uuid.UUID `db:"owner_id" json:"owner_id"`
	Blockchain string    `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetAllNotCreatedWallets(ctx context.Context, blockchains []string) ([]*GetAllNotCreatedWalletsRow, error) {
	rows, err := q.db.Query(ctx, getAllNotCreatedWallets, blockchains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllNotCreatedWalletsRow{}
	for rows.Next() {
		var i GetAllNotCreatedWalletsRow
		if err := rows.Scan(&i.OwnerID, &i.Blockchain); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByBlockchain = `-- name: GetByBlockchain :one
select id, blockchain, address, owner_id, sequence, is_active, is_dirty, created_at, updated_at from processing_wallets where owner_id = $1 and blockchain = $2 limit 1
`

func (q *Queries) GetByBlockchain(ctx context.Context, ownerID uuid.UUID, blockchain wconstants.BlockchainType) (*models.ProcessingWallet, error) {
	row := q.db.QueryRow(ctx, getByBlockchain, ownerID, blockchain)
	var i models.ProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.Sequence,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getByBlockchainAndAddress = `-- name: GetByBlockchainAndAddress :one
select id, blockchain, address, owner_id, sequence, is_active, is_dirty, created_at, updated_at from processing_wallets where blockchain = $1 and address = $2
`

func (q *Queries) GetByBlockchainAndAddress(ctx context.Context, blockchain wconstants.BlockchainType, address string) (*models.ProcessingWallet, error) {
	row := q.db.QueryRow(ctx, getByBlockchainAndAddress, blockchain, address)
	var i models.ProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.Sequence,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getByOwnerID = `-- name: GetByOwnerID :one
select id, blockchain, address, owner_id, sequence, is_active, is_dirty, created_at, updated_at from processing_wallets where address = $3 and owner_id = $1 and blockchain = $2 limit 1
`

func (q *Queries) GetByOwnerID(ctx context.Context, ownerID uuid.UUID, blockchain wconstants.BlockchainType, address string) (*models.ProcessingWallet, error) {
	row := q.db.QueryRow(ctx, getByOwnerID, ownerID, blockchain, address)
	var i models.ProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.Blockchain,
		&i.Address,
		&i.OwnerID,
		&i.Sequence,
		&i.IsActive,
		&i.IsDirty,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const isTakenByAnotherOwner = `-- name: IsTakenByAnotherOwner :one
select exists(select 1 from processing_wallets where owner_id != $1 and address = $2)
`

func (q *Queries) IsTakenByAnotherOwner(ctx context.Context, ownerID uuid.UUID, address string) (bool, error) {
	row := q.db.QueryRow(ctx, isTakenByAnotherOwner, ownerID, address)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
