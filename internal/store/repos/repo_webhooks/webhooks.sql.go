// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package repo_webhooks

import (
	"context"

	"github.com/dv-net/dv-processing/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanup = `-- name: Cleanup :execrows
DELETE FROM webhooks WHERE created_at < $1 AND status = 'sent'
`

func (q *Queries) Cleanup(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, cleanup, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const exists = `-- name: Exists :one
SELECT EXISTS (SELECT 1 FROM webhooks WHERE payload->>'hash'=$1 AND payload->>'type'=$2)::boolean
`

func (q *Queries) Exists(ctx context.Context, payload []byte, payload_2 []byte) (bool, error) {
	row := q.db.QueryRow(ctx, exists, payload, payload_2)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getByID = `-- name: GetByID :one
select id, kind, status, attempts, payload, client_id, response, created_at, sent_at, updated_at, callback_url, secret_key from webhook_view w where w.id = $1 limit 1
`

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (*models.WebhookView, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i models.WebhookView
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Status,
		&i.Attempts,
		&i.Payload,
		&i.ClientID,
		&i.Response,
		&i.CreatedAt,
		&i.SentAt,
		&i.UpdatedAt,
		&i.CallbackUrl,
		&i.SecretKey,
	)
	return &i, err
}

const getUnsent = `-- name: GetUnsent :many
select id, kind, status, attempts, payload, client_id, response, created_at, sent_at, updated_at, callback_url, secret_key from webhook_view w
where
  w.status = $1
  and (
  -- new
    w.updated_at is null
  -- once a minute the first day
    or (extract(epoch from (w.updated_at - w.created_at)) < 3600 * 24)
  -- once an hour the first week
    or (
        extract(epoch from (w.updated_at - w.created_at)) between 3600 * 24 and 3600 * 24 * 7
      and
        extract(epoch from (now() - date_trunc('hour', w.updated_at))) > 3601
    )
  -- once a day
    or (
        extract(epoch from (w.updated_at - w.created_at)) > 3600 * 24 * 7
      and
        date_trunc('day', now()) > date_trunc('day', w.updated_at)
    )
)
order by w.created_at asc
limit $2
`

func (q *Queries) GetUnsent(ctx context.Context, status models.WebhookStatus, limit int32) ([]*models.WebhookView, error) {
	rows, err := q.db.Query(ctx, getUnsent, status, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WebhookView{}
	for rows.Next() {
		var i models.WebhookView
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Status,
			&i.Attempts,
			&i.Payload,
			&i.ClientID,
			&i.Response,
			&i.CreatedAt,
			&i.SentAt,
			&i.UpdatedAt,
			&i.CallbackUrl,
			&i.SecretKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementAttempt = `-- name: IncrementAttempt :exec
update webhooks set updated_at = now(), attempts = attempts + 1, response = $2 where id = $1
`

func (q *Queries) IncrementAttempt(ctx context.Context, iD uuid.UUID, response pgtype.Text) error {
	_, err := q.db.Exec(ctx, incrementAttempt, iD, response)
	return err
}

const setSentAtNow = `-- name: SetSentAtNow :exec
update webhooks set sent_at=now(), response=$2, status='sent', attempts = attempts + 1, updated_at=now() where id=$1
`

func (q *Queries) SetSentAtNow(ctx context.Context, iD uuid.UUID, response pgtype.Text) error {
	_, err := q.db.Exec(ctx, setSentAtNow, iD, response)
	return err
}
